<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Brick Coração</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: url('https://i.imgur.com/Q30yQIT.jpg') no-repeat center center fixed;
      background-size: cover;
      font-family: Arial, sans-serif;
    }

    canvas {
      display: block;
      margin: 20px auto;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 10px;
    }

    #mensagemFinal {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 28px;
      color: #ff69b4;
      font-weight: bold;
      background: rgba(255, 255, 255, 0.8);
      padding: 20px;
      border-radius: 20px;
      display: none;
      text-align: center;
    }

    #placar {
      position: absolute;
      top: 15px;
      left: 15px;
      color: #111;
      font-size: 18px;
      font-weight: bold;
      background: rgba(255,255,255,0.6);
      padding: 8px 12px;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <div id="placar">Pontos: <span id="score">0</span></div>
  <div id="mensagemFinal">❤️ Você é incrível, Ana Carollina Souza ❤️</div>
  <canvas id="gameCanvas" width="400" height="500"></canvas>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const paddleWidth = 80;
    const paddleHeight = 10;
    let paddleX = (canvas.width - paddleWidth) / 2;

    let ballX = canvas.width / 2;
    let ballY = canvas.height - 30;
    let ballRadius = 8;
    let ballSpeedX = 3;
    let ballSpeedY = -3;

    let score = 0;

    const brickRowCount = 5;
    const brickColumnCount = 7;
    const brickWidth = 50;
    const brickHeight = 20;
    const brickPadding = 6;
    const brickOffsetTop = 40;
    const brickOffsetLeft = 20;

    const bricks = [];
    for (let c = 0; c < brickColumnCount; c++) {
      bricks[c] = [];
      for (let r = 0; r < brickRowCount; r++) {
        bricks[c][r] = { x: 0, y: 0, status: 1 };
      }
    }

    function drawBricks() {
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          if (bricks[c][r].status === 1) {
            const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
            const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
            bricks[c][r].x = brickX;
            bricks[c][r].y = brickY;

            ctx.beginPath();
            ctx.moveTo(brickX + brickWidth / 2, brickY);
            ctx.bezierCurveTo(
              brickX, brickY - 15,
              brickX - 25, brickY + 20,
              brickX + brickWidth / 2, brickY + brickHeight
            );
            ctx.bezierCurveTo(
              brickX + brickWidth + 25, brickY + 20,
              brickX + brickWidth, brickY - 15,
              brickX + brickWidth / 2, brickY
            );
            ctx.fillStyle = "#ff69b4";
            ctx.fill();
            ctx.closePath();
          } else if (bricks[c][r].status === 2) {
            const brickX = bricks[c][r].x;
            const brickY = bricks[c][r].y;
            ctx.beginPath();
            ctx.moveTo(brickX + brickWidth / 2, brickY);
            ctx.bezierCurveTo(
              brickX, brickY - 15,
              brickX - 25, brickY + 20,
              brickX + brickWidth / 2, brickY + brickHeight
            );
            ctx.bezierCurveTo(
              brickX + brickWidth + 25, brickY + 20,
              brickX + brickWidth, brickY - 15,
              brickX + brickWidth / 2, brickY
            );
            ctx.fillStyle = "#d63384"; // coração escurecido
            ctx.fill();
            ctx.closePath();
          }
        }
      }
    }

    function drawBall() {
      ctx.beginPath();
      ctx.arc(ballX, ballY, ballRadius, 0, Math.PI * 2);
      ctx.fillStyle = "#ff69b4";
      ctx.fill();
      ctx.closePath();
    }

    function drawPaddle() {
      ctx.beginPath();
      ctx.rect(paddleX, canvas.height - paddleHeight - 10, paddleWidth, paddleHeight);
      ctx.fillStyle = "#111";
      ctx.fill();
      ctx.closePath();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBricks();
      drawBall();
      drawPaddle();

      ballX += ballSpeedX;
      ballY += ballSpeedY;

      if (ballX + ballRadius > canvas.width || ballX - ballRadius < 0) ballSpeedX *= -1;
      if (ballY - ballRadius < 0) ballSpeedY *= -1;

      if (
        ballY + ballRadius > canvas.height - paddleHeight - 10 &&
        ballX > paddleX &&
        ballX < paddleX + paddleWidth
      ) {
        ballSpeedY *= -1;
      }

      if (ballY + ballRadius > canvas.height) {
        document.location.reload();
      }

      collisionDetection();

      requestAnimationFrame(draw);
    }

    function collisionDetection() {
      let bricksRestantes = 0;
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          const b = bricks[c][r];
          if (b.status === 1) {
            bricksRestantes++;
            if (
              ballX > b.x &&
              ballX < b.x + brickWidth &&
              ballY > b.y &&
              ballY < b.y + brickHeight
            ) {
              ballSpeedY *= -1;
              b.status = 2;
              score++;
              document.getElementById("score").textContent = score;
            }
          }
        }
      }

      if (bricksRestantes === 0) {
        document.getElementById("mensagemFinal").style.display = "block";
      }
    }

    // Movimento com mouse
    document.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      paddleX = e.clientX - rect.left - paddleWidth / 2;
    });

    // Movimento com dedo (toque)
    document.addEventListener("touchmove", (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      paddleX = e.touches[0].clientX - rect.left - paddleWidth / 2;
    }, { passive: false });

    // Impedir paddle de sair da tela
    setInterval(() => {
      if (paddleX < 0) paddleX = 0;
      if (paddleX + paddleWidth > canvas.width) paddleX = canvas.width - paddleWidth;
    }, 10);

    draw();
  </script>
</body>
</html>